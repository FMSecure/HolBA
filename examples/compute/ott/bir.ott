embed {{ hol
open wordsTheory;
}}
metavar mmap ::=
  {{ com BIR memory map }}
  {{ hol (num |-> num) }}
metavar ident ::=
  {{ hol string }}
  {{ com Identifier for variable name }}
metavar word_one ::=
  {{ hol word1 }}
  {{ tex \mathit{word1} }}
  {{ com 1-bit word }}
metavar word_eight ::=
  {{ hol word8 }}
  {{ tex \mathit{word8} }}
  {{ com 8-bit word }}
metavar word_sixteen ::=
  {{ hol word16 }}
  {{ tex \mathit{word16} }}
  {{ com 16-bit word }}
metavar word_thirtytwo ::=
  {{ hol word32 }}
  {{ tex \mathit{word32} }}
  {{ com 32-bit word }}
metavar word_sixtyfour ::=
  {{ hol word64 }}
  {{ tex \mathit{word64} }}
  {{ com 64-bit word }}
metavar word_hundredtwentyeight ::=
  {{ hol word128 }}
  {{ tex \mathit{word128} }}
  {{ com 128-bit word }}
grammar
bir_imm_t, bir_imm :: '' ::=
{{ com immediates }}
| Imm_one ( word_one ) :: :: Imm1
| Imm_eight ( word_eight ) :: :: Imm8
| Imm_sixteen ( word_sixteen ) :: :: Imm16
| Imm_thirtytwo ( word_thirtytwo ) :: :: Imm32
| Imm_sixtyfour ( word_sixtyfour ) :: :: Imm64
| Imm_hundredtwentyeight ( word_hundredtwentyeight ) :: :: Imm128

bir_immtype_t, bir_immtype :: '' ::=
{{ com immediate typing size }}
| Bit_one :: :: Bit1
| Bit_eight :: :: Bit8
| Bit_sixteen :: :: Bit16
| Bit_thirtytwo :: :: Bit32
| Bit_sixtyfour :: :: Bit64
| Bit_hundredtwentyeight :: :: Bit128
| type_of_bir_imm ( bir_imm ) :: M :: type_of_bir_imm
  {{ hol (type_of_bir_imm [[bir_imm]]) }}

bir_endian_t, bir_endian :: BEnd_ ::=
{{ com endian for memory operations }}
| BigEndian :: :: BigEndian
| LittleEndian :: :: LittleEndian
| NoEndian :: :: NoEndian

bir_val_t, bir_val :: BVal_ ::=
{{ com values for evaluation relation }}
| Val_Imm ( bir_imm ) :: :: Imm
| Val_Mem ( bir_immtype , bir_immtype' , mmap ) :: :: Mem
  {{ com address type / value type }}

bir_type_t, bir_type :: BType_ ::=
{{ com general typing }}
| Type_Imm ( bir_immtype ) :: :: Imm
| Type_Mem ( bir_immtype , bir_immtype' ) :: :: Mem
| type_of_bir_val ( bir_val ) :: M :: type_of_bir_val
  {{ hol (type_of_bir_val [[bir_val]]) }}

bir_var_t, bir_var :: '' ::=
{{ com variable to lookup in environment }}
| Var ( ident ) :: :: BVar

bir_binexp_t, bir_binexp :: BIExp_ ::=
{{ com binary expressions }}
| And :: :: And
| Plus :: :: Plus

bir_unaryexp_t, bir_unaryexp :: BIExp_ ::=
{{ com unary expressions }}
| ChangeSign :: :: ChangeSign
| Not :: :: Not

bir_binpred_t, bir_binpred :: BIExp_ ::=
{{ com binary predicates }}
| Equal :: :: Equal
| LessThan :: :: LessThan

bir_exp_t, bir_exp :: BExp_ ::=
{{ com BIR expressions }}
| Const ( bir_imm ) :: :: Const
| MemConst ( bir_immtype , bir_immtype' , mmap ) :: :: MemConst
  {{ com address type / value type }}
| Den ( bir_var ) :: :: Den
| BinExp ( bir_binexp , bir_exp1 , bir_exp2 ) :: :: BinExp
| UnaryExp ( bir_unaryexp , bir_exp ) :: :: UnaryExp
| BinPred ( bir_binpred , bir_exp1 , bir_exp2 ) :: :: BinPred
| IfThenElse ( bir_exp , bir_exp1 , bir_exp2 ) :: :: IfThenElse
| Load ( bir_exp1 , bir_exp2 , bir_endian , bir_immtype ) :: :: Load
  {{ com Memory value / Address Value (Imm) / Endian / Type of where to load }}
| Store ( bir_exp1 , bir_exp2 , bir_endian , bir_exp3 ) :: :: Store
  {{ com Memory value / Address Value (Imm) / Endian / Value to store }}

terminals :: terminals_ ::=
| Imm_one :: :: imm_one {{ tex \mathbf{Imm1} }}
| Imm_eight :: :: imm_eight {{ tex \mathbf{Imm8} }}
| Imm_sixteen :: :: imm_sixteen {{ tex \mathbf{Imm16} }}
| Imm_thirtytwo :: :: imm_thirtytwo {{ tex \mathbf{Imm32} }}
| Imm_sixtyfour :: :: imm_sixtyfour {{ tex \mathbf{Imm64} }}
| Imm_hundredtwentyeight :: :: imm_hundredtwentyeight {{ tex \mathbf{Imm128} }}
| Bit_one :: :: Bit_one {{ tex \mathbf{Bit1} }}
| Bit_eight :: :: Bit_eight {{ tex \mathbf{Bit8} }}
| Bit_sixteen :: :: Bit_sixteen {{ tex \mathbf{Bit16} }}
| Bit_thirtytwo :: :: Bit_thirtytwo {{ tex \mathbf{Bit32} }}
| Bit_sixtyfour :: :: Bit_sixtyfour {{ tex \mathbf{Bit64} }}
| Bit_hundredtwentyeight :: :: Bit_hundredtwentyeight {{ tex \mathbf{Bit128} }}
| |- :: :: vdash {{ tex \vdash }}

embed {{ hol
(* Booleans *)

Definition bool2w_def:
  bool2w b = (if b then 1w else 0w):word1
End

Definition bool2b_def:
  bool2b b = Imm1 (bool2w b)
End

Definition birT_def:
  birT = BVal_Imm (Imm1 1w)
End

Definition birF_def:
  birF = BVal_Imm (Imm1 0w)
End

(* Correction Theorems of boolean functions *)
Theorem bool2b_T_eq_birT:
  BVal_Imm (bool2b T) = birT
Proof
  rw [bool2b_def, bool2w_def, birT_def]
QED

Theorem bool2b_F_eq_birF:
  BVal_Imm (bool2b F) = birF
Proof
  rw [bool2b_def, bool2w_def, birF_def]
QED

(* Utility functions *)
Definition bir_dest_bool_val_def:
  (bir_dest_bool_val (BVal_Imm (Imm1 w)) = SOME (w = 1w)) /\
  (bir_dest_bool_val _ = NONE)
End

Definition val_from_imm_option_def:
  (val_from_imm_option NONE = NONE) /\
  (val_from_imm_option (SOME imm) = SOME (BVal_Imm imm))
End

(* ------ Env ------- *)

Datatype:
  bir_var_environment_t = BEnv (ident -> (bir_val_t option))
End

(* Lookup function *)
Definition bir_env_lookup_def:
  bir_env_lookup (BEnv env) (BVar id) = env id
End

(* Lookup relation *)
Definition bir_env_lookup_rel_def:
  bir_env_lookup_rel (BEnv env) (BVar id) a = (env id = (SOME a)) 
End

(* Empty environment *)
Definition bir_empty_env_def:
  bir_empty_env = BEnv (\x. NONE)
End

(* Update environment *)
(* Slightly differs from original as we donâ€™t check for existence here *)
Definition bir_env_update_def:
  bir_env_update ((BEnv env):bir_var_environment_t) (BVar id) v = BEnv ((id =+ SOME v) env)
End

Theorem bir_env_lookup_empty:
  !var v. ~(bir_env_lookup_rel bir_empty_env var v)
Proof
  Cases_on `var` >>
  rw [bir_empty_env_def, bir_env_lookup_rel_def]
QED

Theorem bir_env_lookup_rel_update:
  !env var v. bir_env_lookup_rel (bir_env_update env var v) var v 
Proof
  Cases_on `var` >> Cases_on `env` >>
  rw [bir_env_update_def, bir_env_lookup_rel_def]
QED

Theorem bir_env_lookup_update:
  !env var v. bir_env_lookup (bir_env_update env var v) var = SOME v 
Proof
  rpt gen_tac >>
  Cases_on `var` >> Cases_on `env` >>
  rw [bir_env_update_def, bir_env_lookup_def]
QED

Theorem bir_env_lookup_update_neq:
  !env var1 var2 v. 
    var1 <> var2 ==>
      bir_env_lookup (bir_env_update env var1 v) var2 = bir_env_lookup env var2
Proof
  Cases_on `var1` >> Cases_on `var2` >>
  rw [fetch "-" "bir_var_t_11"] >>
  Cases_on `env` >>
  simp [bir_env_update_def] >>
  rw [bir_env_lookup_def] >>
  EVAL_TAC >>
  metis_tac []
QED

(* Lookup and relation are the same *)
Theorem bir_env_lookup_eq_rel:
  !env var v. bir_env_lookup_rel env var v <=> bir_env_lookup env var = SOME v
Proof
  rpt strip_tac >>
  Cases_on `env` >>
  Cases_on `var` >>
    rw [bir_env_lookup_def, bir_env_lookup_rel_def]
QED


(* Injective *)
Theorem bir_env_lookup_rel_inj:
  !env var v1 v2.
    bir_env_lookup_rel env var v1 ==>
    bir_env_lookup_rel env var v2 ==>
    v1 = v2
Proof
  Cases_on `env` >> Cases_on `var` >>
    simp [bir_env_lookup_rel_def]
QED

(* --------- Typing ------- *)

(* Gives the size of an immediate as a number *)
Definition size_of_bir_immtype_def:
  (size_of_bir_immtype Bit1 = 1) /\
  (size_of_bir_immtype Bit8 = 8) /\
  (size_of_bir_immtype Bit16 = 16) /\
  (size_of_bir_immtype Bit32 = 32) /\
  (size_of_bir_immtype Bit64 = 64) /\
  (size_of_bir_immtype Bit128 = 128) 
End

(* Typing function for immediates *)
Definition type_of_bir_imm_def:
  (type_of_bir_imm (Imm1 w) = Bit1) /\
  (type_of_bir_imm (Imm8 w) = Bit8) /\
  (type_of_bir_imm (Imm16 w) = Bit16) /\
  (type_of_bir_imm (Imm32 w) = Bit32) /\
  (type_of_bir_imm (Imm64 w) = Bit64) /\
  (type_of_bir_imm (Imm128 w) = Bit128)
End

(* Typing function for values *)
Definition type_of_bir_val_def:
  (type_of_bir_val (BVal_Imm imm) = (BType_Imm (type_of_bir_imm imm))) /\
  (type_of_bir_val (BVal_Mem aty vty mmap) = (BType_Mem aty vty) )
End
}}

metavar bir_var_environment_t, bir_var_environment, env ::=
 {{ hol bir_var_environment_t }}

grammar

formula :: formula_ ::=          
| judgement           ::   :: judgement
| bir_env_lookup_rel ( bir_var_environment , bir_var , bir_val ) :: M :: bir_env_lookup_rel
  {{ hol (bir_env_lookup_rel [[bir_var_environment]] [[bir_var]] [[bir_val]]) }}
| n = n' :: M :: n_eq
  {{ hol ([[n]] = [[n']]) }}
| n '<=' n' :: M :: n_lt
  {{ hol ([[n]] <= [[n']]) }}

n :: n_ ::=
  {{ hol num }}
| n MOD n' :: M :: mod
  {{ hol ([[n]] MOD [[n']]) }}
| n DIV n' :: M :: div
  {{ hol ([[n]] DIV [[n']]) }}
| 2 ^ n :: M :: two_pow
  {{ hol (2**[[n]]) }}
| 0 :: M :: zero
  {{ hol 0 }}
| 1 :: M :: one
  {{ hol 1 }}
| size_of_bir_immtype ( bir_immtype ) :: M :: size_of_bir_immtype
  {{ hol (size_of_bir_immtype [[bir_immtype]]) }}

defns
  type_of_bir_exp :: '' ::= 

defn
  bir_var_environment |- bir_exp : bir_type :: :: type_of_bir_exp :: BExp_
  {{ com typing relation for BIR expressions }} by

  --------------- :: Const
  env |- Const(bir_imm) : Type_Imm(type_of_bir_imm(bir_imm))

  ----------------- :: MemConst
  env |- MemConst(bir_immtype1,bir_immtype2,mmap) : Type_Mem(bir_immtype1,bir_immtype2)

  bir_env_lookup_rel(env,bir_var,bir_val)
  -------------------------------------- :: Den
  env |- Den(bir_var) : type_of_bir_val(bir_val)

  env |- bir_exp1 : Type_Imm(bir_immtype)
  env |- bir_exp2 : Type_Imm(bir_immtype)
  ------------------------------ :: BinExp
  env |- BinExp(bir_binexp,bir_exp1,bir_exp2) : Type_Imm(bir_immtype)

  env |- bir_exp : Type_Imm(bir_immtype)
  -------------------------------------- :: UnaryExp
  env |- UnaryExp(bir_unaryexp,bir_exp) : Type_Imm(bir_immtype)

  env |- bir_exp1 : Type_Imm(bir_immtype)
  env |- bir_exp2 : Type_Imm(bir_immtype)
  ------------------------------ :: BinPred
  env |- BinPred(bir_binpred,bir_exp1,bir_exp2) : Type_Imm(Bit_one)

  env |- bir_exp1 : bir_type
  env |- bir_exp2 : bir_type
  env |- bir_exp : Type_Imm(Bit_one)
  ------------------------------ :: IfThenElse
  env |- IfThenElse(bir_exp,bir_exp1,bir_exp2) : bir_type

  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) = 1
  ----------------------------------- :: Load_NoEndian
  env |- Load(bir_exp1,bir_exp2,NoEndian,bir_immtype) : Type_Imm(bir_immtype)

  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  -------- :: Load_BigEndian
  env |- Load(bir_exp1,bir_exp2,BigEndian,bir_immtype) : Type_Imm(bir_immtype)

  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  -------- :: Load_LittleEndian
  env |- Load(bir_exp1,bir_exp2,LittleEndian,bir_immtype) : Type_Imm(bir_immtype)
  
  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  env |- bir_exp3 : Type_Imm(bir_immtype)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) = 1
  ------------------------------------------------------------ :: Store_NoEndian
  env |- Store(bir_exp1,bir_exp2,NoEndian,bir_exp3) : Type_Mem(bir_immtype1,bir_immtype2)

  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  env |- bir_exp3 : Type_Imm(bir_immtype)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  ------------------------------------------------------------ :: Store_BigEndian
  env |- Store(bir_exp1,bir_exp2,BigEndian,bir_exp3) : Type_Mem(bir_immtype1,bir_immtype2)

  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  env |- bir_exp3 : Type_Imm(bir_immtype)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  ------------------------------------------------------------ :: Store_LittleEndian
  env |- Store(bir_exp1,bir_exp2,LittleEndian,bir_exp3) : Type_Mem(bir_immtype1,bir_immtype2)
  
embed {{ hol

Definition is_exp_well_typed_def:
  is_exp_well_typed env exp = ?ty. type_of_bir_exp env exp ty
End

(* 1 bit values are booleans *)
Theorem bit1_is_boolean:
  !v. type_of_bir_val v = (BType_Imm Bit1) ==> (v = birT \/ v = birF)
Proof
  Cases_on `v` >>
    Cases_on `b` >>
      rw [birT_def, birF_def, type_of_bir_val_def, type_of_bir_imm_def] >>
      Cases_on `c` >>
        fs [dimword_1]
QED
}}
