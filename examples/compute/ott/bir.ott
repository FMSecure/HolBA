embed {{ hol
open wordsTheory;
open bitstringTheory numeral_bitTheory;
}}
metavar mmap ::=
  {{ com BIR memory map }}
  {{ hol (num |-> num) }}
metavar ident ::=
  {{ hol string }}
  {{ com Identifier for variable name }}
metavar word_one ::=
  {{ hol word1 }}
  {{ tex \mathit{word1} }}
  {{ com 1-bit word }}
metavar word_eight ::=
  {{ hol word8 }}
  {{ tex \mathit{word8} }}
  {{ com 8-bit word }}
metavar word_sixteen ::=
  {{ hol word16 }}
  {{ tex \mathit{word16} }}
  {{ com 16-bit word }}
metavar word_thirtytwo ::=
  {{ hol word32 }}
  {{ tex \mathit{word32} }}
  {{ com 32-bit word }}
metavar word_sixtyfour ::=
  {{ hol word64 }}
  {{ tex \mathit{word64} }}
  {{ com 64-bit word }}
metavar word_hundredtwentyeight ::=
  {{ hol word128 }}
  {{ tex \mathit{word128} }}
  {{ com 128-bit word }}
grammar
bir_imm_t, bir_imm :: '' ::=
{{ com immediates }}
| Imm_one ( word_one ) :: :: Imm1
| Imm_eight ( word_eight ) :: :: Imm8
| Imm_sixteen ( word_sixteen ) :: :: Imm16
| Imm_thirtytwo ( word_thirtytwo ) :: :: Imm32
| Imm_sixtyfour ( word_sixtyfour ) :: :: Imm64
| Imm_hundredtwentyeight ( word_hundredtwentyeight ) :: :: Imm128

bir_immtype_t, bir_immtype :: '' ::=
{{ com immediate typing size }}
| Bit_one :: :: Bit1
| Bit_eight :: :: Bit8
| Bit_sixteen :: :: Bit16
| Bit_thirtytwo :: :: Bit32
| Bit_sixtyfour :: :: Bit64
| Bit_hundredtwentyeight :: :: Bit128
| type_of_bir_imm ( bir_imm ) :: M :: type_of_bir_imm
  {{ hol (type_of_bir_imm [[bir_imm]]) }}

bir_endian_t, bir_endian :: BEnd_ ::=
{{ com endian for memory operations }}
| BigEndian :: :: BigEndian
| LittleEndian :: :: LittleEndian
| NoEndian :: :: NoEndian

bir_val_t, bir_val :: BVal_ ::=
{{ com values for evaluation relation }}
| Val_Imm ( bir_imm ) :: :: Imm
| Val_Mem ( bir_immtype , bir_immtype' , mmap ) :: :: Mem
  {{ com address type / value type }}

bir_type_t, bir_type :: BType_ ::=
{{ com general typing }}
| Type_Imm ( bir_immtype ) :: :: Imm
| Type_Mem ( bir_immtype , bir_immtype' ) :: :: Mem
| type_of_bir_val ( bir_val ) :: M :: type_of_bir_val
  {{ hol (type_of_bir_val [[bir_val]]) }}

bir_var_t, bir_var :: '' ::=
{{ com variable to lookup in environment }}
| Var ( ident ) :: :: BVar

bir_binexp_t, bir_binexp :: BIExp_ ::=
{{ com binary expressions }}
| And :: :: And
| Plus :: :: Plus

bir_unaryexp_t, bir_unaryexp :: BIExp_ ::=
{{ com unary expressions }}
| ChangeSign :: :: ChangeSign
| Not :: :: Not

bir_binpred_t, bir_binpred :: BIExp_ ::=
{{ com binary predicates }}
| Equal :: :: Equal
| LessThan :: :: LessThan

bir_exp_t, bir_exp :: BExp_ ::=
{{ com BIR expressions }}
| Const ( bir_imm ) :: :: Const
| MemConst ( bir_immtype , bir_immtype' , mmap ) :: :: MemConst
  {{ com address type / value type }}
| Den ( bir_var ) :: :: Den
| BinExp ( bir_binexp , bir_exp1 , bir_exp2 ) :: :: BinExp
| UnaryExp ( bir_unaryexp , bir_exp ) :: :: UnaryExp
| BinPred ( bir_binpred , bir_exp1 , bir_exp2 ) :: :: BinPred
| IfThenElse ( bir_exp , bir_exp1 , bir_exp2 ) :: :: IfThenElse
| Load ( bir_exp1 , bir_exp2 , bir_endian , bir_immtype ) :: :: Load
  {{ com Memory value / Address Value (Imm) / Endian / Type of where to load }}
| Store ( bir_exp1 , bir_exp2 , bir_endian , bir_exp3 ) :: :: Store
  {{ com Memory value / Address Value (Imm) / Endian / Value to store }}

terminals :: terminals_ ::=
| Imm_one :: :: imm_one {{ tex \mathbf{Imm1} }}
| Imm_eight :: :: imm_eight {{ tex \mathbf{Imm8} }}
| Imm_sixteen :: :: imm_sixteen {{ tex \mathbf{Imm16} }}
| Imm_thirtytwo :: :: imm_thirtytwo {{ tex \mathbf{Imm32} }}
| Imm_sixtyfour :: :: imm_sixtyfour {{ tex \mathbf{Imm64} }}
| Imm_hundredtwentyeight :: :: imm_hundredtwentyeight {{ tex \mathbf{Imm128} }}
| Bit_one :: :: Bit_one {{ tex \mathbf{Bit1} }}
| Bit_eight :: :: Bit_eight {{ tex \mathbf{Bit8} }}
| Bit_sixteen :: :: Bit_sixteen {{ tex \mathbf{Bit16} }}
| Bit_thirtytwo :: :: Bit_thirtytwo {{ tex \mathbf{Bit32} }}
| Bit_sixtyfour :: :: Bit_sixtyfour {{ tex \mathbf{Bit64} }}
| Bit_hundredtwentyeight :: :: Bit_hundredtwentyeight {{ tex \mathbf{Bit128} }}
| |- :: :: vdash {{ tex \vdash }}
| ~> :: :: leadsto {{ tex \leadsto }}

embed {{ hol
(* Booleans *)

Definition bool2w_def:
  bool2w b = (if b then 1w else 0w):word1
End

Definition bool2b_def:
  bool2b b = Imm1 (bool2w b)
End

Definition birT_def:
  birT = BVal_Imm (Imm1 1w)
End

Definition birF_def:
  birF = BVal_Imm (Imm1 0w)
End

(* Correction Theorems of boolean functions *)
Theorem bool2b_T_eq_birT:
  BVal_Imm (bool2b T) = birT
Proof
  rw [bool2b_def, bool2w_def, birT_def]
QED

Theorem bool2b_F_eq_birF:
  BVal_Imm (bool2b F) = birF
Proof
  rw [bool2b_def, bool2w_def, birF_def]
QED

(* Utility functions *)
Definition bir_dest_bool_val_def:
  (bir_dest_bool_val (BVal_Imm (Imm1 w)) = SOME (w = 1w)) /\
  (bir_dest_bool_val _ = NONE)
End

Definition val_from_imm_option_def:
  (val_from_imm_option NONE = NONE) /\
  (val_from_imm_option (SOME imm) = SOME (BVal_Imm imm))
End

(* ------ Env ------- *)

Datatype:
  bir_var_environment_t = BEnv (ident -> (bir_val_t option))
End

(* Lookup function *)
Definition bir_env_lookup_def:
  bir_env_lookup (BEnv env) (BVar id) = env id
End

(* Lookup relation *)
Definition bir_env_lookup_rel_def:
  bir_env_lookup_rel (BEnv env) (BVar id) a = (env id = (SOME a)) 
End

(* Empty environment *)
Definition bir_empty_env_def:
  bir_empty_env = BEnv (\x. NONE)
End

(* Update environment *)
(* Slightly differs from original as we donâ€™t check for existence here *)
Definition bir_env_update_def:
  bir_env_update ((BEnv env):bir_var_environment_t) (BVar id) v = BEnv ((id =+ SOME v) env)
End

Theorem bir_env_lookup_empty:
  !var v. ~(bir_env_lookup_rel bir_empty_env var v)
Proof
  Cases_on `var` >>
  rw [bir_empty_env_def, bir_env_lookup_rel_def]
QED

Theorem bir_env_lookup_rel_update:
  !env var v. bir_env_lookup_rel (bir_env_update env var v) var v 
Proof
  Cases_on `var` >> Cases_on `env` >>
  rw [bir_env_update_def, bir_env_lookup_rel_def]
QED

Theorem bir_env_lookup_update:
  !env var v. bir_env_lookup (bir_env_update env var v) var = SOME v 
Proof
  rpt gen_tac >>
  Cases_on `var` >> Cases_on `env` >>
  rw [bir_env_update_def, bir_env_lookup_def]
QED

Theorem bir_env_lookup_update_neq:
  !env var1 var2 v. 
    var1 <> var2 ==>
      bir_env_lookup (bir_env_update env var1 v) var2 = bir_env_lookup env var2
Proof
  Cases_on `var1` >> Cases_on `var2` >>
  rw [fetch "-" "bir_var_t_11"] >>
  Cases_on `env` >>
  simp [bir_env_update_def] >>
  rw [bir_env_lookup_def] >>
  EVAL_TAC >>
  metis_tac []
QED

(* Lookup and relation are the same *)
Theorem bir_env_lookup_eq_rel:
  !env var v. bir_env_lookup_rel env var v <=> bir_env_lookup env var = SOME v
Proof
  rpt strip_tac >>
  Cases_on `env` >>
  Cases_on `var` >>
    rw [bir_env_lookup_def, bir_env_lookup_rel_def]
QED


(* Injective *)
Theorem bir_env_lookup_rel_inj:
  !env var v1 v2.
    bir_env_lookup_rel env var v1 ==>
    bir_env_lookup_rel env var v2 ==>
    v1 = v2
Proof
  Cases_on `env` >> Cases_on `var` >>
    simp [bir_env_lookup_rel_def]
QED

(* --------- Typing ------- *)

(* Gives the size of an immediate as a number *)
Definition size_of_bir_immtype_def:
  (size_of_bir_immtype Bit1 = 1) /\
  (size_of_bir_immtype Bit8 = 8) /\
  (size_of_bir_immtype Bit16 = 16) /\
  (size_of_bir_immtype Bit32 = 32) /\
  (size_of_bir_immtype Bit64 = 64) /\
  (size_of_bir_immtype Bit128 = 128) 
End

(* Typing function for immediates *)
Definition type_of_bir_imm_def:
  (type_of_bir_imm (Imm1 w) = Bit1) /\
  (type_of_bir_imm (Imm8 w) = Bit8) /\
  (type_of_bir_imm (Imm16 w) = Bit16) /\
  (type_of_bir_imm (Imm32 w) = Bit32) /\
  (type_of_bir_imm (Imm64 w) = Bit64) /\
  (type_of_bir_imm (Imm128 w) = Bit128)
End

(* Typing function for values *)
Definition type_of_bir_val_def:
  (type_of_bir_val (BVal_Imm imm) = (BType_Imm (type_of_bir_imm imm))) /\
  (type_of_bir_val (BVal_Mem aty vty mmap) = (BType_Mem aty vty) )
End
}}

metavar bir_var_environment_t, bir_var_environment, env ::=
 {{ hol bir_var_environment_t }}

grammar

formula :: formula_ ::=          
| judgement           ::   :: judgement
| bir_env_lookup_rel ( bir_var_environment , bir_var , bir_val ) :: M :: bir_env_lookup_rel
  {{ hol (bir_env_lookup_rel [[bir_var_environment]] [[bir_var]] [[bir_val]]) }}
| n = n' :: M :: n_eq
  {{ hol ([[n]] = [[n']]) }}
| n '<=' n' :: M :: n_lt
  {{ hol ([[n]] <= [[n']]) }}
%| bir_binexp bir_imm1 bir_imm2 ~> bir_imm :: M :: bir_eval_binexp_imm
%  {{ hol (bir_eval_binexp_imm [[bir_imm1]] [[bir_imm2]] [[bir_imm]]) }}
| bir_binexp bir_val1 bir_val2 ~> bir_val :: M :: bir_eval_binexp
  {{ hol (bir_eval_binexp [[bir_binexp]] [[bir_val1]] [[bir_val2]] [[bir_val]]) }}
| bir_unaryexp bir_val ~> bir_val' :: M :: bir_eval_unaryexp
  {{ hol (bir_eval_unaryexp [[bir_unaryexp]] [[bir_val]] [[bir_val']]) }}
| bir_binpred bir_val1 bir_val2 ~> bir_val :: M :: bir_eval_binpred
  {{ hol (bir_eval_binpred [[bir_binpred]] [[bir_val1]] [[bir_val2]] [[bir_val]]) }}
| bir_val bir_val1 bir_val2 ~> bir_val' :: M :: bir_eval_ifthenelse
  {{ hol (bir_eval_ifthenelse [[bir_val]] [[bir_val1]] [[bir_val2]] [[bir_val']]) }}
| bir_val1 bir_val2 bir_endian bir_immtype ~> bir_val3 :: M :: bir_eval_load
  {{ hol (bir_eval_load [[bir_val1]] [[bir_val2]] [[bir_endian]] [[bir_immtype]] [[bir_val3]]) }}
| bir_val1 bir_val2 bir_endian bir_val3 ~> bir_val :: M :: bir_eval_store
  {{ hol (bir_eval_store [[bir_val1]] [[bir_val2]] [[bir_endian]] [[bir_val3]] [[bir_val]]) }}

n :: n_ ::=
  {{ hol num }}
| n MOD n' :: M :: mod
  {{ hol ([[n]] MOD [[n']]) }}
| n DIV n' :: M :: div
  {{ hol ([[n]] DIV [[n']]) }}
| 2 ^ n :: M :: two_pow
  {{ hol (2**[[n]]) }}
| 0 :: M :: zero
  {{ hol 0 }}
| 1 :: M :: one
  {{ hol 1 }}
| size_of_bir_immtype ( bir_immtype ) :: M :: size_of_bir_immtype
  {{ hol (size_of_bir_immtype [[bir_immtype]]) }}

defns
  type_of_bir_exp :: '' ::= 

defn
  bir_var_environment |- bir_exp : bir_type :: :: type_of_bir_exp :: Type_BExp_
  {{ com typing relation for BIR expressions }} by

  --------------- :: Const
  env |- Const(bir_imm) : Type_Imm(type_of_bir_imm(bir_imm))

  ----------------- :: MemConst
  env |- MemConst(bir_immtype1,bir_immtype2,mmap) : Type_Mem(bir_immtype1,bir_immtype2)

  bir_env_lookup_rel(env,bir_var,bir_val)
  -------------------------------------- :: Den
  env |- Den(bir_var) : type_of_bir_val(bir_val)

  env |- bir_exp1 : Type_Imm(bir_immtype)
  env |- bir_exp2 : Type_Imm(bir_immtype)
  ------------------------------ :: BinExp
  env |- BinExp(bir_binexp,bir_exp1,bir_exp2) : Type_Imm(bir_immtype)

  env |- bir_exp : Type_Imm(bir_immtype)
  -------------------------------------- :: UnaryExp
  env |- UnaryExp(bir_unaryexp,bir_exp) : Type_Imm(bir_immtype)

  env |- bir_exp1 : Type_Imm(bir_immtype)
  env |- bir_exp2 : Type_Imm(bir_immtype)
  ------------------------------ :: BinPred
  env |- BinPred(bir_binpred,bir_exp1,bir_exp2) : Type_Imm(Bit_one)

  env |- bir_exp1 : bir_type
  env |- bir_exp2 : bir_type
  env |- bir_exp : Type_Imm(Bit_one)
  ------------------------------ :: IfThenElse
  env |- IfThenElse(bir_exp,bir_exp1,bir_exp2) : bir_type

  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) = 1
  ----------------------------------- :: Load_NoEndian
  env |- Load(bir_exp1,bir_exp2,NoEndian,bir_immtype) : Type_Imm(bir_immtype)

  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  -------- :: Load_BigEndian
  env |- Load(bir_exp1,bir_exp2,BigEndian,bir_immtype) : Type_Imm(bir_immtype)

  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  -------- :: Load_LittleEndian
  env |- Load(bir_exp1,bir_exp2,LittleEndian,bir_immtype) : Type_Imm(bir_immtype)
  
  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  env |- bir_exp3 : Type_Imm(bir_immtype)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) = 1
  ------------------------------------------------------------ :: Store_NoEndian
  env |- Store(bir_exp1,bir_exp2,NoEndian,bir_exp3) : Type_Mem(bir_immtype1,bir_immtype2)

  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  env |- bir_exp3 : Type_Imm(bir_immtype)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  ------------------------------------------------------------ :: Store_BigEndian
  env |- Store(bir_exp1,bir_exp2,BigEndian,bir_exp3) : Type_Mem(bir_immtype1,bir_immtype2)

  env |- bir_exp1 : Type_Mem(bir_immtype1,bir_immtype2)
  env |- bir_exp2 : Type_Imm(bir_immtype1)
  env |- bir_exp3 : Type_Imm(bir_immtype)
  size_of_bir_immtype(bir_immtype) MOD size_of_bir_immtype(bir_immtype2) = 0
  size_of_bir_immtype(bir_immtype) DIV size_of_bir_immtype(bir_immtype2) <= 2^size_of_bir_immtype(bir_immtype1)
  ------------------------------------------------------------ :: Store_LittleEndian
  env |- Store(bir_exp1,bir_exp2,LittleEndian,bir_exp3) : Type_Mem(bir_immtype1,bir_immtype2)
  
embed {{ hol

Definition is_exp_well_typed_def:
  is_exp_well_typed env exp = ?ty. type_of_bir_exp env exp ty
End

(* 1 bit values are booleans *)
Theorem bit1_is_boolean:
  !v. type_of_bir_val v = (BType_Imm Bit1) ==> (v = birT \/ v = birF)
Proof
  Cases_on `v` >>
    Cases_on `b` >>
      rw [birT_def, birF_def, type_of_bir_val_def, type_of_bir_imm_def] >>
      Cases_on `c` >>
        fs [dimword_1]
QED

(* Gets the operator for a given binary operation *)
Definition bir_binexp_get_oper_def:
  (bir_binexp_get_oper BIExp_And = word_and) /\
  (bir_binexp_get_oper BIExp_Plus = word_add)
End
(* Evaluates a binary expression of two immediates *)
Inductive bir_eval_binexp_imm:
  (!binexp w1 w2. 
    bir_eval_binexp_imm binexp (Imm1 w1) (Imm1 w2) (Imm1 ((bir_binexp_get_oper binexp) w1 w2))) /\
  (!binexp w1 w2. 
    bir_eval_binexp_imm binexp (Imm8 w1) (Imm8 w2) (Imm8 ((bir_binexp_get_oper binexp) w1 w2))) /\
  (!binexp w1 w2. 
    bir_eval_binexp_imm binexp (Imm16 w1) (Imm16 w2) (Imm16 ((bir_binexp_get_oper binexp) w1 w2))) /\
  (!binexp w1 w2. 
    bir_eval_binexp_imm binexp (Imm32 w1) (Imm32 w2) (Imm32 ((bir_binexp_get_oper binexp) w1 w2))) /\
  (!binexp w1 w2. 
    bir_eval_binexp_imm binexp (Imm64 w1) (Imm64 w2) (Imm64 ((bir_binexp_get_oper binexp) w1 w2))) /\
  (!binexp w1 w2. 
    bir_eval_binexp_imm binexp (Imm128 w1) (Imm128 w2) (Imm128 ((bir_binexp_get_oper binexp) w1 w2)))
End

(* Evaluates a general binary expression with values as parameters *)
Definition bir_eval_binexp_def:
  (bir_eval_binexp binexp (BVal_Imm imm1) (BVal_Imm imm2) (BVal_Imm imm) =
    (bir_eval_binexp_imm binexp imm1 imm2 imm)) /\
  (bir_eval_binexp _ _ _ _ = F)
End

(* Computes a binary expression of two immediates *)
Definition bir_compute_binexp_imm_def:
  (bir_compute_binexp_imm BIExp_And (Imm1 w1) (Imm1 w2) = SOME (Imm1 (word_and w1 w2))) /\
  (bir_compute_binexp_imm BIExp_And (Imm8 w1) (Imm8 w2) = SOME (Imm8 (word_and w1 w2))) /\
  (bir_compute_binexp_imm BIExp_And (Imm16 w1) (Imm16 w2) = SOME (Imm16 (word_and w1 w2))) /\
  (bir_compute_binexp_imm BIExp_And (Imm32 w1) (Imm32 w2) = SOME (Imm32 (word_and w1 w2))) /\
  (bir_compute_binexp_imm BIExp_And (Imm64 w1) (Imm64 w2) = SOME (Imm64 (word_and w1 w2))) /\
  (bir_compute_binexp_imm BIExp_And (Imm128 w1) (Imm128 w2) = SOME (Imm128 (word_and w1 w2))) /\
  (bir_compute_binexp_imm BIExp_Plus (Imm1 w1) (Imm1 w2) = SOME (Imm1 (word_add w1 w2))) /\
  (bir_compute_binexp_imm BIExp_Plus (Imm8 w1) (Imm8 w2) = SOME (Imm8 (word_add w1 w2))) /\
  (bir_compute_binexp_imm BIExp_Plus (Imm16 w1) (Imm16 w2) = SOME (Imm16 (word_add w1 w2))) /\
  (bir_compute_binexp_imm BIExp_Plus (Imm32 w1) (Imm32 w2) = SOME (Imm32 (word_add w1 w2))) /\
  (bir_compute_binexp_imm BIExp_Plus (Imm64 w1) (Imm64 w2) = SOME (Imm64 (word_add w1 w2))) /\
  (bir_compute_binexp_imm BIExp_Plus (Imm128 w1) (Imm128 w2) = SOME (Imm128 (word_add w1 w2))) /\
  (bir_compute_binexp_imm binexp _ _ = NONE)
End


(* Computes a general binary expression with values as parameters *)
Definition bir_compute_binexp_def:
  (bir_compute_binexp binexp (SOME (BVal_Imm imm1)) (SOME (BVal_Imm imm2)) =
    val_from_imm_option (bir_compute_binexp_imm binexp imm1 imm2)) /\
  (bir_compute_binexp _ _ _ = NONE)
End

(* Eval and compute are similar *)
Theorem bir_eval_binexp_eq_compute_binexp:
  !binexp v1 v2 v. bir_eval_binexp binexp v1 v2 v <=> 
    bir_compute_binexp binexp (SOME v1) (SOME v2) = SOME v
Proof
  Cases_on `binexp` >>
  Cases_on `v1` >> Cases_on `v2` >> Cases_on `v` >>
    rw [bir_eval_binexp_def, bir_compute_binexp_def] >>
    rw [bir_eval_binexp_imm_cases, bir_compute_binexp_imm_def] >>
    Cases_on `b` >> Cases_on `b'` >> Cases_on `b''` >>
      rw [bir_compute_binexp_imm_def, fetch "-" "bir_imm_t_nchotomy", bir_binexp_get_oper_def] >>
      rw [val_from_imm_option_def] >>
      metis_tac []
QED


(* If the operands are typed, then the expression evaluates *)
Theorem type_of_bir_val_imp_bir_eval_binexp:
  !binexp v1 v2 ty.
    ((type_of_bir_val v1 = BType_Imm ty) /\ (type_of_bir_val v2 = BType_Imm ty)) ==>
    ?v. bir_eval_binexp binexp v1 v2 v
Proof
  Cases_on `binexp` >>
  Cases_on `v1` >> Cases_on `v2` >>
  Cases_on `b` >> Cases_on `b'` >>
    rw [bir_eval_binexp_eq_compute_binexp] >>
    rw [bir_compute_binexp_def, bir_compute_binexp_imm_def] >>
    rw [val_from_imm_option_def] >>
    fs [type_of_bir_val_def, type_of_bir_imm_def]
QED


(* Type conservation Theorem *)
Theorem bir_eval_binexp_keep_type:
  !binexp v1 v2 v ty.
    bir_eval_binexp binexp v1 v2 v ==>
    ((type_of_bir_val v1 = ty /\ type_of_bir_val v2 = ty) <=>
      type_of_bir_val v = ty)
Proof
  Cases_on `v1` >> Cases_on `v2` >> Cases_on `v` >>
  Cases_on `b` >> Cases_on `b'` >> Cases_on `b''` >>
    rw [type_of_bir_val_def, bir_eval_binexp_def, type_of_bir_imm_def, bir_eval_binexp_imm_cases]
QED

(* Gets the operator for a given unary operation *)
Definition bir_unaryexp_get_oper_def:
  (bir_unaryexp_get_oper BIExp_Not = word_1comp) /\
  (bir_unaryexp_get_oper BIExp_ChangeSign = word_2comp)
End


(* Evaluates a binary expression of an immediate *)
Inductive bir_eval_unaryexp_imm:
  (!unaryexp w1. 
    bir_eval_unaryexp_imm unaryexp (Imm1 w1) (Imm1 ((bir_unaryexp_get_oper unaryexp) w1))) /\
  (!unaryexp w1. 
    bir_eval_unaryexp_imm unaryexp (Imm8 w1) (Imm8 ((bir_unaryexp_get_oper unaryexp) w1))) /\
  (!unaryexp w1. 
    bir_eval_unaryexp_imm unaryexp (Imm16 w1) (Imm16 ((bir_unaryexp_get_oper unaryexp) w1))) /\
  (!unaryexp w1. 
    bir_eval_unaryexp_imm unaryexp (Imm32 w1) (Imm32 ((bir_unaryexp_get_oper unaryexp) w1))) /\
  (!unaryexp w1. 
    bir_eval_unaryexp_imm unaryexp (Imm64 w1) (Imm64 ((bir_unaryexp_get_oper unaryexp) w1))) /\
  (!unaryexp w1. 
    bir_eval_unaryexp_imm unaryexp (Imm128 w1) (Imm128 ((bir_unaryexp_get_oper unaryexp) w1)))
End


(* Evaluates a general unary expression with values as parameters *)
Definition bir_eval_unaryexp_def:
  (bir_eval_unaryexp unaryexp (BVal_Imm imm1) (BVal_Imm imm) =
    (bir_eval_unaryexp_imm unaryexp imm1 imm)) /\
  (bir_eval_unaryexp _ _ _ = F)
End

(* Computes a binary expression of an immediate *)
Definition bir_compute_unaryexp_imm_def:
  (bir_compute_unaryexp_imm BIExp_Not (Imm1 w1) = SOME (Imm1 (word_1comp w1))) /\
  (bir_compute_unaryexp_imm BIExp_Not (Imm8 w1) = SOME (Imm8 (word_1comp w1))) /\
  (bir_compute_unaryexp_imm BIExp_Not (Imm16 w1) = SOME (Imm16 (word_1comp w1))) /\
  (bir_compute_unaryexp_imm BIExp_Not (Imm32 w1) = SOME (Imm32 (word_1comp w1))) /\
  (bir_compute_unaryexp_imm BIExp_Not (Imm64 w1) = SOME (Imm64 (word_1comp w1))) /\
  (bir_compute_unaryexp_imm BIExp_Not (Imm128 w1) = SOME (Imm128 (word_1comp w1))) /\
  (bir_compute_unaryexp_imm BIExp_ChangeSign (Imm1 w1) = SOME (Imm1 (word_2comp w1))) /\
  (bir_compute_unaryexp_imm BIExp_ChangeSign (Imm8 w1) = SOME (Imm8 (word_2comp w1))) /\
  (bir_compute_unaryexp_imm BIExp_ChangeSign (Imm16 w1) = SOME (Imm16 (word_2comp w1))) /\
  (bir_compute_unaryexp_imm BIExp_ChangeSign (Imm32 w1) = SOME (Imm32 (word_2comp w1))) /\
  (bir_compute_unaryexp_imm BIExp_ChangeSign (Imm64 w1) = SOME (Imm64 (word_2comp w1))) /\
  (bir_compute_unaryexp_imm BIExp_ChangeSign (Imm128 w1) = SOME (Imm128 (word_2comp w1)))
End

(* Computes Unary expression *)
Definition bir_compute_unaryexp_def:
  (bir_compute_unaryexp unaryexp (SOME (BVal_Imm imm1)) = 
    val_from_imm_option (bir_compute_unaryexp_imm unaryexp imm1)) /\
  (bir_compute_unaryexp _ _ = NONE)
End

(* Eval and Compute are similar *)
Theorem bir_eval_unaryexp_eq_compute_unaryexp:
  !unaryexp v1 v. bir_eval_unaryexp unaryexp v1 v <=> 
    bir_compute_unaryexp unaryexp (SOME v1) = SOME v
Proof
  Cases_on `unaryexp` >>
  Cases_on `v1` >> Cases_on `v` >>
    rw [bir_eval_unaryexp_def, bir_compute_unaryexp_def] >>
    rw [bir_eval_unaryexp_imm_cases, bir_compute_unaryexp_imm_def] >>
    Cases_on `b` >> Cases_on `b'` >>
      rw [bir_compute_unaryexp_imm_def, fetch "-" "bir_imm_t_nchotomy", bir_unaryexp_get_oper_def] >>
      rw [val_from_imm_option_def] >>
      metis_tac []
QED


(* Unary_exp always evaluates *)
Theorem type_of_bir_val_imp_bir_eval_unaryexp:
  !unaryexp v ty.
    (type_of_bir_val v = BType_Imm ty) ==>
    ?v'. bir_eval_unaryexp unaryexp v v'
Proof
  Cases_on `unaryexp` >>
  Cases_on `v` >>
  Cases_on `b` >>
    rw [bir_eval_unaryexp_eq_compute_unaryexp, type_of_bir_val_def] >>
    rw [bir_compute_unaryexp_def, bir_compute_unaryexp_imm_def] >>
    rw [val_from_imm_option_def] >>
    fs [type_of_bir_val_def, type_of_bir_imm_def]
QED

(* Type conservation theorem *)
Theorem bir_eval_unaryexp_keep_type:
  !unaryexp v1 v2 ty.
    bir_eval_unaryexp unaryexp v1 v2 ==>
    (type_of_bir_val v1 = type_of_bir_val v2)
Proof
  Cases_on `v1` >> Cases_on `v2` >>
  Cases_on `b` >> Cases_on `b'` >>
    rw [type_of_bir_val_def, bir_eval_unaryexp_def, type_of_bir_imm_def, bir_eval_unaryexp_imm_cases]
QED

(* Gets the operator for a given binary predicate *)
Definition bir_binpred_get_oper_def:
  (bir_binpred_get_oper BIExp_Equal = $=) /\
  (bir_binpred_get_oper BIExp_LessThan = word_lo)
End


(* Evaluates a binary predicate of two immediates *)
Inductive bir_eval_binpred_imm:
  (!binpred w1 w2. 
    bir_eval_binpred_imm binpred (Imm1 w1) (Imm1 w2) ((bir_binpred_get_oper binpred) w1 w2)) /\
  (!binpred w1 w2. 
    bir_eval_binpred_imm binpred (Imm8 w1) (Imm8 w2) ((bir_binpred_get_oper binpred) w1 w2)) /\
  (!binpred w1 w2. 
    bir_eval_binpred_imm binpred (Imm16 w1) (Imm16 w2) ((bir_binpred_get_oper binpred) w1 w2)) /\
  (!binpred w1 w2. 
    bir_eval_binpred_imm binpred (Imm32 w1) (Imm32 w2) ((bir_binpred_get_oper binpred) w1 w2)) /\
  (!binpred w1 w2. 
    bir_eval_binpred_imm binpred (Imm64 w1) (Imm64 w2) ((bir_binpred_get_oper binpred) w1 w2)) /\
  (!binpred w1 w2. 
    bir_eval_binpred_imm binpred (Imm128 w1) (Imm128 w2) ((bir_binpred_get_oper binpred) w1 w2))
End


(* Evaluates a general binary predicate with values as parameters *)
Inductive bir_eval_binpred:
  (!binpred imm1 imm2 b. 
    (bir_eval_binpred_imm binpred imm1 imm2 b) ==>
    (bir_eval_binpred binpred (BVal_Imm imm1) (BVal_Imm imm2) (BVal_Imm (bool2b b))))
End

(* Computes a binary predicate of two immediates *)
Definition bir_compute_binpred_imm_def:
  (bir_compute_binpred_imm BIExp_Equal (Imm1 w1) (Imm1 w2) = $= w1 w2) /\
  (bir_compute_binpred_imm BIExp_Equal (Imm8 w1) (Imm8 w2) = $= w1 w2) /\
  (bir_compute_binpred_imm BIExp_Equal (Imm16 w1) (Imm16 w2) = $= w1 w2) /\
  (bir_compute_binpred_imm BIExp_Equal (Imm32 w1) (Imm32 w2) = $= w1 w2) /\
  (bir_compute_binpred_imm BIExp_Equal (Imm64 w1) (Imm64 w2) = $= w1 w2) /\
  (bir_compute_binpred_imm BIExp_Equal (Imm128 w1) (Imm128 w2) = $= w1 w2) /\
  (bir_compute_binpred_imm BIExp_LessThan (Imm1 w1) (Imm1 w2) = word_lo w1 w2) /\
  (bir_compute_binpred_imm BIExp_LessThan (Imm8 w1) (Imm8 w2) = word_lo w1 w2) /\
  (bir_compute_binpred_imm BIExp_LessThan (Imm16 w1) (Imm16 w2) = word_lo w1 w2) /\
  (bir_compute_binpred_imm BIExp_LessThan (Imm32 w1) (Imm32 w2) = word_lo w1 w2) /\
  (bir_compute_binpred_imm BIExp_LessThan (Imm64 w1) (Imm64 w2) = word_lo w1 w2) /\
  (bir_compute_binpred_imm BIExp_LessThan (Imm128 w1) (Imm128 w2) = word_lo w1 w2) /\
  (bir_compute_binpred_imm binpred _ _ = F)
End


(* Computes a general binary predicate with values as parameters *)
Definition bir_compute_binpred_def:
  (bir_compute_binpred binpred (SOME (BVal_Imm imm1)) (SOME (BVal_Imm imm2)) =
    SOME (BVal_Imm (bool2b (bir_compute_binpred_imm binpred imm1 imm2)))) /\
  (bir_compute_binpred _ _ _ = NONE)
End

Theorem bir_eval_binpred_imp_compute_binpred:
  !binpred v1 v2 v. bir_eval_binpred binpred v1 v2 v ==> 
    bir_compute_binpred binpred (SOME v1) (SOME v2) = SOME v
Proof
  Cases_on `binpred` >>
  Cases_on `v1` >> Cases_on `v2` >> Cases_on `v` >>
    rw [bir_eval_binpred_cases, bir_compute_binpred_def] >>
    rw [bir_eval_binpred_imm_cases, bir_compute_binpred_imm_def] >>
    Cases_on `b` >> Cases_on `b'` >>
      rw [bool2b_def, bool2w_def, bir_compute_binpred_imm_def, fetch "-" "bir_imm_t_nchotomy"] >>
      fs [bir_eval_binpred_imm_cases, bir_binpred_get_oper_def] >>
      metis_tac []
QED

(* If the term is well typed, then eval and compute are the same *)
Theorem well_typed_bir_eval_binpred_eq_compute_binpred:
  !binpred v1 v2 v. 
    (type_of_bir_val v1 = type_of_bir_val v2) ==>
  ( bir_eval_binpred binpred v1 v2 v <=> 
    bir_compute_binpred binpred (SOME v1) (SOME v2) = SOME v)
Proof
  Cases_on `binpred` >>
  Cases_on `v1` >> Cases_on `v2` >> Cases_on `v` >>
  rw [bir_eval_binpred_cases, bir_compute_binpred_def] >>
  rw [bir_eval_binpred_imm_cases, bir_compute_binpred_imm_def] >>
  Cases_on `b` >> Cases_on `b'` >>
    rw [bool2b_def, bool2w_def, bir_compute_binpred_imm_def, fetch "-" "bir_imm_t_nchotomy"] >>
    fs [bir_eval_binpred_imm_cases, type_of_bir_val_def, type_of_bir_imm_def,
      bir_binpred_get_oper_def] >>
    metis_tac []
QED


(* If the operands are typed, then the expression evaluates *)
Theorem type_of_bir_val_imp_bir_eval_binpred:
  !binpred v1 v2 ty.
    ((type_of_bir_val v1 = BType_Imm ty) /\ (type_of_bir_val v2 = BType_Imm ty)) ==>
    ?v. bir_eval_binpred binpred v1 v2 v
Proof
  Cases_on `v1` >> Cases_on `v2` >>
  Cases_on `b` >> Cases_on `b'` >>
    rw [well_typed_bir_eval_binpred_eq_compute_binpred] >>
    rw [bir_compute_binpred_def, bir_compute_binpred_imm_def] >>
    fs [type_of_bir_val_def, type_of_bir_imm_def]
QED


(* Type conservation theorem *)
Theorem bir_eval_binpred_correct_type:
  !binpred v1 v2 v ty.
    bir_eval_binpred binpred v1 v2 v ==>
    ((type_of_bir_val v1 = type_of_bir_val v2) /\ type_of_bir_val v = (BType_Imm Bit1))
Proof
  Cases_on `v1` >> Cases_on `v2` >> Cases_on `v` >>
  Cases_on `b` >> Cases_on `b'` >> Cases_on `b''` >>
    rw [type_of_bir_val_def, bir_eval_binpred_cases, type_of_bir_imm_def, bir_eval_binpred_imm_cases, bool2b_def]
QED

(* Evaluates a general ifthenelse expression with values as parameters *)
Inductive bir_eval_ifthenelse:
[~BExp_IfThenElseT:]
  bir_eval_ifthenelse birT (v1:bir_val_t) (v2:bir_val_t) v1 

[~BExp_IfThenElseF:]
  bir_eval_ifthenelse birF v1 v2 v2
End

(* Computes an ifthenelse expression of two values *)
Definition bir_compute_ifthenelse_def:
  bir_compute_ifthenelse b v1 v2 = 
    if b = SOME birT then v1 
    else if b = SOME birF then v2
    else NONE
End
(* Eval and compute are similar *)
Theorem bir_eval_ifthenelse_eq_compute_ifthenelse:
  !v (v1:bir_val_t) (v2:bir_val_t) (v3:bir_val_t).
  (bir_eval_ifthenelse v v1 v2 v3 <=>
    bir_compute_ifthenelse (SOME v) (SOME v1) (SOME v2) = SOME v3)
Proof
  Cases_on `v` >> Cases_on `v1` >> Cases_on `v2` >> Cases_on `v3` >>
  rw [bir_eval_ifthenelse_cases, bir_compute_ifthenelse_def, birT_def, birF_def] >>
    metis_tac []
QED

(* If the condition is typed, then the expression evaluates *)
Theorem type_of_bir_val_imp_bir_eval_ifthenelse:
  !v v1 v2.
    (type_of_bir_val v = (BType_Imm Bit1)) ==>
    ?v3. bir_eval_ifthenelse v v1 v2 v3
Proof
  rw [bir_eval_ifthenelse_eq_compute_ifthenelse] >>
  Cases_on `v` >| [
    Cases_on `b` >>
    Cases_on `c` >>
      metis_tac [bir_compute_ifthenelse_def, bit1_is_boolean],

    fs [type_of_bir_val_def]
    ]
QED

(* Type conservation Theorem *)
Theorem bir_eval_ifthenelse_keep_type:
  !v v1 v2 v3 ty.
    bir_eval_ifthenelse v v1 v2 v3 ==>
    (type_of_bir_val v1 = ty /\ type_of_bir_val v2 = ty) ==>
    (type_of_bir_val v = (BType_Imm Bit1) <=> type_of_bir_val v3 = ty)
Proof
  Cases_on `v` >> Cases_on `v1` >> Cases_on `v2` >> Cases_on `v3` >>
  Cases_on `b` >> Cases_on `b'` >> Cases_on `b''` >> Cases_on `b'''` >>
  rw [type_of_bir_val_def, bir_eval_ifthenelse_cases, type_of_bir_imm_def,
    birT_def, birF_def]
QED

(* Number to Bitstring *)
Definition n2bs_def:
  (n2bs n Bit1   = Imm1   (n2w n)) /\
  (n2bs n Bit8   = Imm8   (n2w n)) /\
  (n2bs n Bit16  = Imm16  (n2w n)) /\
  (n2bs n Bit32  = Imm32  (n2w n)) /\
  (n2bs n Bit64  = Imm64  (n2w n)) /\
  (n2bs n Bit128 = Imm128 (n2w n))
End

(* Boolean list (vector) to bitstring *)
Definition v2bs_def:
  v2bs v s = n2bs (v2n v) s
End


(* Immediate to number *)
Definition b2n_def:
  (b2n ( Imm1   w ) = w2n w) /\
  (b2n ( Imm8   w ) = w2n w) /\
  (b2n ( Imm16  w ) = w2n w) /\
  (b2n ( Imm32  w ) = w2n w) /\
  (b2n ( Imm64  w ) = w2n w) /\
  (b2n ( Imm128 w ) = w2n w)
End

(* Immediate to bitstring *)
Definition b2v_def:
  (b2v ( Imm1   w ) = w2v w) /\
  (b2v ( Imm8   w ) = w2v w) /\
  (b2v ( Imm16  w ) = w2v w) /\
  (b2v ( Imm32  w ) = w2v w) /\
  (b2v ( Imm64  w ) = w2v w) /\
  (b2v ( Imm128 w ) = w2v w)
End

Definition bitstring_split_aux_def:
  (bitstring_split_aux 0 acc bs = NONE) /\
  (bitstring_split_aux n acc [] = SOME $ REVERSE acc) /\
  (bitstring_split_aux n acc bs =
    bitstring_split_aux n ((TAKE n bs)::acc) (DROP n bs))
Termination
  WF_REL_TAC `measure (\ (_, _, l). LENGTH l)` >>
  simp_tac list_ss []
End

(* Splits a bitstring in chunks of n bits *)
Definition bitstring_split_def:
  bitstring_split n bs = bitstring_split_aux n [] bs
End


(* ------------------------------------------ *)
(* ------------------ LOAD ------------------ *)
(* ------------------------------------------ *)


(* Load a value from the mmap at the given address *)
Definition bir_load_mmap_def:
  bir_load_mmap (mmap: num |-> num) a =
      case FLOOKUP mmap a of
        | NONE => 0
        | SOME v => v
End


(* Concatenate multiple bitstrings to a number on the correct number of bits *)
Definition bir_mem_concat_def:
  bir_mem_concat vl rty = v2bs (FLAT vl) rty
End

(* Compute the address modulo the address space *)
Definition bir_mem_addr_def:
  bir_mem_addr aty a = MOD_2EXP (size_of_bir_immtype aty) a
End

(* Computes the number of memory splits we will read *)
Definition bir_number_of_mem_splits_def:
  bir_number_of_mem_splits vty rty aty =
    if ((size_of_bir_immtype rty) MOD (size_of_bir_immtype vty) = 0) then
      if ((size_of_bir_immtype rty) DIV (size_of_bir_immtype vty) <= 
        2 **(size_of_bir_immtype aty)) then
          SOME ((size_of_bir_immtype rty) DIV (size_of_bir_immtype vty))
      else NONE
    else NONE
End


(* Load a bitstring at the given address from a mmap and pad it *)
Definition bir_load_bitstring_from_mmap_def:
  bir_load_bitstring_from_mmap vty mmap (a:num) =
    fixwidth (size_of_bir_immtype vty) (n2v (bir_load_mmap mmap a))
End
  
(* Load n splits of size vty from mmap starting at addr *) 
Definition bir_load_splits_from_mmap_def:
  bir_load_splits_from_mmap aty vty mmap addr n =
    (MAP (\k. bir_load_bitstring_from_mmap vty mmap (bir_mem_addr aty (addr + k))) (COUNT_LIST n)) 
End


(* Eval an already unpacked load expression *)
Inductive bir_eval_load_from_mem:
[~BEnd_BigEndian:]
  (!aty vty mmap addr rty n.
    (bir_number_of_mem_splits vty rty aty = SOME n)
    ==>
    bir_eval_load_from_mem vty rty aty mmap BEnd_BigEndian addr 
      (BVal_Imm (bir_mem_concat (bir_load_splits_from_mmap aty vty mmap addr n) rty)))

[~BEnd_LittleEndian:]
  (!aty vty mmap addr rty n.
    (bir_number_of_mem_splits vty rty aty = SOME n)
    ==>
    bir_eval_load_from_mem vty rty aty mmap BEnd_LittleEndian addr
      (BVal_Imm (bir_mem_concat (REVERSE (bir_load_splits_from_mmap aty vty mmap addr n)) rty)))

[~BEnd_NoEndian:]
  (!aty vty mmap addr rty.
    (bir_number_of_mem_splits vty rty aty = SOME 1)
    ==>
    bir_eval_load_from_mem vty rty aty mmap BEnd_NoEndian addr
      (BVal_Imm (bir_mem_concat (bir_load_splits_from_mmap aty vty mmap addr 1) rty)))
End

Definition bir_eval_load_def:
  (bir_eval_load (BVal_Mem aty vty mmap) (BVal_Imm addr) en rty v = 
    bir_eval_load_from_mem vty rty aty mmap en (b2n addr) v) /\
  (bir_eval_load _ _ _ _ _ = F)
End

(* Computes an already unpacked load expression *)
Definition bir_compute_load_from_mem_def:
  bir_compute_load_from_mem
  (vty : bir_immtype_t) (rty : bir_immtype_t) (aty : bir_immtype_t) (mmap : num |-> num) (en: bir_endian_t) (addr:num) =

   case (bir_number_of_mem_splits vty rty aty) of
    | NONE => NONE
    | SOME (n:num) => (
        let vs = bir_load_splits_from_mmap aty vty mmap addr n in
        let vs' = (case en of BEnd_LittleEndian => SOME (REVERSE vs)
                          |  BEnd_BigEndian => SOME vs
                          |  BEnd_NoEndian => if (n = 1) then SOME vs else NONE) in
        case vs' of NONE => NONE
                 |  SOME vs'' => SOME (bir_mem_concat vs'' rty)
   )
End

Definition bir_compute_load_def:
  (bir_compute_load (SOME (BVal_Mem aty vty mmap)) (SOME (BVal_Imm addr)) en rty = 
    val_from_imm_option (bir_compute_load_from_mem vty rty aty mmap en (b2n addr))) /\
  (bir_compute_load _ _ _ _ = NONE)
End


(* ----------------------------------------- *)
(* ----------------- STORE ----------------- *)
(* ----------------------------------------- *)


(* Add all the bitstrings in the mmap at address a *)
Definition bir_update_mmap_def:
  (bir_update_mmap aty mmap a [] = mmap) /\
  (bir_update_mmap aty mmap a (v::vs) =
    bir_update_mmap aty (FUPDATE mmap ((bir_mem_addr aty a), v2n v)) (SUC a) vs)
End


Inductive bir_eval_store_in_mem:
[~BEnd_BigEndian:]
  !vty aty result mmap addr ll.
    (bir_number_of_mem_splits vty (type_of_bir_imm result) aty = SOME _) /\
    (bitstring_split (size_of_bir_immtype vty) (b2v result) = SOME ll)
    ==>
    bir_eval_store_in_mem vty aty result mmap BEnd_BigEndian addr
      (BVal_Mem aty vty (bir_update_mmap aty mmap addr ll))

[~BEnd_LittleEndian:]
  !vty aty result mmap addr ll.
    (bir_number_of_mem_splits vty (type_of_bir_imm result) aty = SOME _) /\
    (bitstring_split (size_of_bir_immtype vty) (b2v result) = SOME ll)
    ==>
    bir_eval_store_in_mem vty aty result mmap BEnd_LittleEndian addr
      (BVal_Mem aty vty (bir_update_mmap aty mmap addr (REVERSE ll)))

[~BEnd_NoEndian:]
  !vty aty result mmap addr ll.
    (bir_number_of_mem_splits vty (type_of_bir_imm result) aty = SOME 1) /\
    (bitstring_split (size_of_bir_immtype vty) (b2v result) = SOME ll)
    ==>
    bir_eval_store_in_mem vty aty result mmap BEnd_NoEndian addr
      (BVal_Mem aty vty (bir_update_mmap aty mmap addr ll))

End

Definition bir_eval_store_def:
  (bir_eval_store (BVal_Mem aty vty mmap) (BVal_Imm addr) en (BVal_Imm result) v = 
    bir_eval_store_in_mem vty aty result mmap en (b2n addr) v) /\
  (bir_eval_store _ _ _ _ _ = F)
End

(* Compute an already unpacked store expression *)
Definition bir_compute_store_in_mem_def:
  bir_compute_store_in_mem
  (vty : bir_immtype_t) (aty : bir_immtype_t) (result : bir_imm_t) (mmap : num |-> num) (en: bir_endian_t) (addr:num) =

   let rty = type_of_bir_imm result in
   case (bir_number_of_mem_splits vty rty aty) of
    | NONE => NONE
    | SOME (n:num) => (
      case  (bitstring_split (size_of_bir_immtype vty) (b2v result)) of
        | NONE => NONE
        | SOME vs =>
        let vs' = (case en of BEnd_LittleEndian => SOME (REVERSE vs)
                          |  BEnd_BigEndian => SOME vs
                          |  BEnd_NoEndian => if (n = 1) then SOME vs else NONE) in

        case vs' of NONE => NONE
                 |  SOME vs'' => SOME (BVal_Mem aty vty (bir_update_mmap aty mmap addr vs''))
   )
End


Definition bir_compute_store_def:
  (bir_compute_store (SOME (BVal_Mem aty vty mmap)) (SOME (BVal_Imm addr)) en (SOME (BVal_Imm result)) = 
    bir_compute_store_in_mem vty aty result mmap en (b2n addr)) /\
  (bir_compute_store _ _ _ _ = NONE)
End

Theorem size_of_bir_immtype_leq_1:
  !b. 1 <= 2 ** (size_of_bir_immtype b)
Proof
  Cases_on `b` >>
  rw [size_of_bir_immtype_def]
QED

(* Eval and compute are similar *)
Theorem bir_eval_load_eq_compute_load:
  !v_mem v_addr en rty v.
    bir_eval_load v_mem v_addr en rty v <=>
    (bir_compute_load (SOME v_mem) (SOME v_addr) en rty = SOME v)
Proof
  Cases_on `v_mem` >> Cases_on `v_addr` >> Cases_on `en` >>
    rw [bir_eval_load_def, bir_eval_load_from_mem_cases] >>
    rw [bir_compute_load_def, bir_compute_load_from_mem_def] >>
    CASE_TAC >>
    simp [] >>
    rw [val_from_imm_option_def] >>
    metis_tac []
QED



(* If the operands are correctly typed, then the expression evaluates *)
Theorem type_of_bir_val_imp_bir_eval_load_bigendian:
  !aty vty v_mem v_addr rty.
  ((type_of_bir_val v_mem = (BType_Mem aty vty)) /\ 
    (type_of_bir_val v_addr = BType_Imm aty) /\
     ((size_of_bir_immtype rty) MOD (size_of_bir_immtype vty) = 0) /\
     ((size_of_bir_immtype rty) DIV (size_of_bir_immtype vty) <= 
        2 **(size_of_bir_immtype aty)))
  ==>
  ?v. bir_eval_load v_mem v_addr BEnd_BigEndian rty v
Proof
  Cases_on `v_mem` >> Cases_on `v_addr` >>
    rw [bir_eval_load_eq_compute_load] >>
    rw [bir_compute_load_def, bir_compute_load_from_mem_def, bir_number_of_mem_splits_def] >>
    fs [type_of_bir_val_def, type_of_bir_imm_def] >>
    rw [val_from_imm_option_def] >>
    metis_tac []
QED

Theorem type_of_bir_val_imp_bir_eval_load_littleendian:
  !aty vty v_mem v_addr rty.
  ((type_of_bir_val v_mem = (BType_Mem aty vty)) /\ 
    (type_of_bir_val v_addr = BType_Imm aty) /\
     ((size_of_bir_immtype rty) MOD (size_of_bir_immtype vty) = 0) /\
     ((size_of_bir_immtype rty) DIV (size_of_bir_immtype vty) <= 
        2 **(size_of_bir_immtype aty)))
  ==>
  ?v. bir_eval_load v_mem v_addr BEnd_LittleEndian rty v
Proof
  Cases_on `v_mem` >> Cases_on `v_addr` >>
    rw [bir_eval_load_eq_compute_load] >>
    rw [bir_compute_load_def, bir_compute_load_from_mem_def, bir_number_of_mem_splits_def] >>
    fs [type_of_bir_val_def, type_of_bir_imm_def] >>
    rw [val_from_imm_option_def] >>
    metis_tac []
QED

Theorem type_of_bir_val_imp_bir_eval_load_noendian:
  !aty vty v_mem v_addr rty.
  ((type_of_bir_val v_mem = (BType_Mem aty vty)) /\ 
    (type_of_bir_val v_addr = BType_Imm aty) /\
     ((size_of_bir_immtype rty) MOD (size_of_bir_immtype vty) = 0) /\
     ((size_of_bir_immtype rty) DIV (size_of_bir_immtype vty) <= 
        2 **(size_of_bir_immtype aty)) /\
     ((size_of_bir_immtype rty) DIV (size_of_bir_immtype vty) = 1))
  ==>
  ?v. bir_eval_load v_mem v_addr BEnd_NoEndian rty v
Proof
  Cases_on `v_mem` >> Cases_on `v_addr` >>
    rw [bir_eval_load_eq_compute_load] >>
    rw [bir_compute_load_def, bir_compute_load_from_mem_def, bir_number_of_mem_splits_def] >>
    fs [type_of_bir_val_def, type_of_bir_imm_def] >>
    rw [val_from_imm_option_def] >>
    metis_tac [size_of_bir_immtype_leq_1]
QED


(* Type of bir_mem_concat *)
Theorem type_of_bir_imm_bir_mem_concat:
  !vl rty. type_of_bir_imm (bir_mem_concat vl rty) = rty
Proof
  Cases_on `rty` >>
    rw [bir_mem_concat_def, v2bs_def, n2bs_def] >>
    rw [type_of_bir_imm_def]
QED
  

(* Type conservation theorem *)
Theorem bir_eval_load_correct_type:
  !v_mem v_addr en rty v.
    bir_eval_load v_mem v_addr en rty v ==>
    (type_of_bir_val v = (BType_Imm rty))
Proof
  Cases_on `v_mem` >> Cases_on `v_addr` >>
  Cases_on `en` >>

  simp [bir_eval_load_def, bir_eval_load_from_mem_cases] >>
  metis_tac [type_of_bir_val_def, type_of_bir_imm_def, type_of_bir_imm_bir_mem_concat]
QED

(* bitstring_split will never be NONE *)
Theorem bitstring_split_aux_size_of_bir_immtype:
  !ty acc bs. ?ll. bitstring_split_aux (size_of_bir_immtype ty) acc bs = SOME ll
Proof
  gen_tac >>
  `?n. size_of_bir_immtype ty = SUC n` by (Cases_on `ty` >> simp [size_of_bir_immtype_def]) >>
  measureInduct_on `LENGTH bs` >>
    Cases_on `bs` >>
    fs [bitstring_split_def, bitstring_split_aux_def] >>
    `LENGTH (DROP n t) < SUC (LENGTH t)` by rw [listTheory.LENGTH_DROP] >>
    metis_tac [bitstring_split_aux_def, listTheory.LENGTH_DROP]
QED

Theorem bitstring_split_size_of_bir_immtype:
  !ty bs. bitstring_split (size_of_bir_immtype ty) bs <> NONE
Proof
  simp [bitstring_split_def] >>
  metis_tac [bitstring_split_aux_size_of_bir_immtype, optionTheory.NOT_SOME_NONE]
QED

(* Eval and compute are similar *)
Theorem bir_eval_store_eq_compute_store:
  !v_mem v_addr en result v.
    bir_eval_store v_mem v_addr en result v <=>
    (bir_compute_store (SOME v_mem) (SOME v_addr) en (SOME result) = SOME v)
Proof
  Cases_on `v_mem` >> Cases_on `v_addr` >> Cases_on `en` >> Cases_on `result` >>
    rw [bir_eval_store_def, bir_eval_store_in_mem_cases] >>
    rw [bir_compute_store_def, bir_compute_store_in_mem_def] >>
    CASE_TAC >> CASE_TAC >> TRY CASE_TAC >>
      simp [] >>
      metis_tac []
QED

(* If the operands are correctly typed, then the expression evaluates *)
Theorem type_of_bir_val_imp_bir_eval_store_bigendian:
  !aty vty v_mem v_addr v_result rty.
  ((type_of_bir_val v_mem = (BType_Mem aty vty)) /\ 
    (type_of_bir_val v_addr = BType_Imm aty) /\
    (type_of_bir_val v_result = BType_Imm rty) /\
     ((size_of_bir_immtype rty) MOD (size_of_bir_immtype vty) = 0) /\
     ((size_of_bir_immtype rty) DIV (size_of_bir_immtype vty) <= 
        2 **(size_of_bir_immtype aty)))
  ==>
  ?v. bir_eval_store v_mem v_addr BEnd_BigEndian v_result v
Proof
  Cases_on `v_mem` >> Cases_on `v_addr` >> Cases_on `v_result` >>
    rw [bir_eval_store_eq_compute_store] >>
    rw [bir_compute_store_def, bir_compute_store_in_mem_def, bir_number_of_mem_splits_def] >>
    fs [type_of_bir_val_def, type_of_bir_imm_def] >>
    TRY CASE_TAC >>
      fs [bitstring_split_size_of_bir_immtype, bitstring_split_def] >>
      metis_tac [bitstring_split_aux_size_of_bir_immtype]
QED

Theorem type_of_bir_val_imp_bir_eval_store_littleendian:
  !aty vty v_mem v_addr v_result rty.
  ((type_of_bir_val v_mem = (BType_Mem aty vty)) /\ 
    (type_of_bir_val v_addr = BType_Imm aty) /\
    (type_of_bir_val v_result = BType_Imm rty) /\
     ((size_of_bir_immtype rty) MOD (size_of_bir_immtype vty) = 0) /\
     ((size_of_bir_immtype rty) DIV (size_of_bir_immtype vty) <= 
        2 **(size_of_bir_immtype aty)))
  ==>
  ?v. bir_eval_store v_mem v_addr BEnd_LittleEndian v_result v
Proof
  Cases_on `v_mem` >> Cases_on `v_addr` >> Cases_on `v_result` >>
    rw [bir_eval_store_eq_compute_store] >>
    rw [bir_compute_store_def, bir_compute_store_in_mem_def, bir_number_of_mem_splits_def] >>
    fs [type_of_bir_val_def, type_of_bir_imm_def] >>
    TRY CASE_TAC >>
      fs [bitstring_split_size_of_bir_immtype] >>
      metis_tac []
QED

Theorem type_of_bir_val_imp_bir_eval_store_noendian:
  !aty vty v_mem v_addr v_result rty.
  ((type_of_bir_val v_mem = (BType_Mem aty vty)) /\ 
    (type_of_bir_val v_addr = BType_Imm aty) /\
    (type_of_bir_val v_result = BType_Imm rty) /\
     ((size_of_bir_immtype rty) MOD (size_of_bir_immtype vty) = 0) /\
     ((size_of_bir_immtype rty) DIV (size_of_bir_immtype vty) <= 
        2 **(size_of_bir_immtype aty)) /\
     ((size_of_bir_immtype rty) DIV (size_of_bir_immtype vty) = 1))
  ==>
  ?v. bir_eval_store v_mem v_addr BEnd_NoEndian v_result v
Proof
  Cases_on `v_mem` >> Cases_on `v_addr` >> Cases_on `v_result` >>
    rw [bir_eval_store_eq_compute_store] >>
    rw [bir_compute_store_def, bir_compute_store_in_mem_def, bir_number_of_mem_splits_def] >>
    fs [type_of_bir_val_def, type_of_bir_imm_def] >>
    TRY CASE_TAC >>
      fs [bitstring_split_size_of_bir_immtype] >>
      metis_tac [size_of_bir_immtype_leq_1]
QED

(* Type conservation theorem *)
Theorem bir_eval_store_correct_type:
  !v_mem v_addr en v_result v.
    bir_eval_store v_mem v_addr en v_result v ==>
    (type_of_bir_val v = type_of_bir_val v_mem)
Proof
  Cases_on `v_mem` >> Cases_on `v_addr` >> Cases_on `v_result` >>
  Cases_on `en` >>

  simp [bir_eval_store_def, bir_eval_store_in_mem_cases] >>
  rw [type_of_bir_val_def, type_of_bir_imm_def] >>
  metis_tac [type_of_bir_val_def, type_of_bir_imm_def]
QED
}}

defns
  bir_eval_exp :: '' ::=

defn
  bir_var_environment |- bir_exp ~> bir_val :: :: bir_eval_exp :: Eval_BExp_
  {{ com typing relation for BIR expressions }} by

  ----------- :: Const
  env |- Const(bir_imm) ~> Val_Imm(bir_imm)

  ------------ :: MemConst
  env |- MemConst(bir_immtype1,bir_immtype2,mmap) ~> Val_Mem(bir_immtype1,bir_immtype2,mmap)

  bir_env_lookup_rel(env,bir_var,bir_val)
  --------- :: Den
  env |- Den(bir_var) ~> bir_val

  env |- bir_exp1 ~> bir_val1
  env |- bir_exp2 ~> bir_val2
  bir_binexp bir_val1 bir_val2 ~> bir_val
  ------------- :: BinExp
  env |- BinExp(bir_binexp,bir_exp1,bir_exp2) ~> bir_val

  env |- bir_exp ~> bir_val
  bir_unaryexp bir_val ~> bir_val'
  ------ :: UnaryExp
  env |- UnaryExp(bir_unaryexp,bir_exp) ~> bir_val'

  env |- bir_exp1 ~> bir_val1
  env |- bir_exp2 ~> bir_val2
  bir_binpred bir_val1 bir_val2 ~> bir_val
  ----- :: BinPred
  env |- BinPred(bir_binpred,bir_exp1,bir_exp2) ~> bir_val

  env |- bir_exp ~> bir_val
  env |- bir_exp1 ~> bir_val1
  env |- bir_exp2 ~> bir_val2
  bir_val bir_val1 bir_val2 ~> bir_val3
  ----------- :: IfThenElse
  env |- IfThenElse(bir_exp,bir_exp1,bir_exp2) ~> bir_val3

  env |- bir_exp1 ~> bir_val1
  env |- bir_exp2 ~> bir_val2
  bir_val1 bir_val2 bir_endian bir_immtype ~> bir_val
  ------------ :: Load
  env |- Load(bir_exp1,bir_exp2,bir_endian,bir_immtype) ~> bir_val

  env |- bir_exp1 ~> bir_val1
  env |- bir_exp2 ~> bir_val2
  env |- bir_exp3 ~> bir_val3
  bir_val1 bir_val2 bir_endian bir_val3 ~> bir_val
  ----- :: Store
  env |- Store(bir_exp1,bir_exp2,bir_endian,bir_exp3) ~> bir_val
