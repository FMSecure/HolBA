(* generated by Ott 0.33 from: bir.ott *)
(* to compile: Holmake birTheory.uo   *)
(* for interactive use:
  app load ["pred_setTheory","finite_mapTheory","stringTheory","containerTheory","ottLib"];
*)

open HolKernel boolLib Parse bossLib ottLib;
infix THEN THENC |-> ## ;
local open arithmeticTheory stringTheory containerTheory pred_setTheory listTheory 
  finite_mapTheory in end;

val _ = new_theory "bir";

open wordsTheory;

Type mmap = ``:(num |-> num)`` (* BIR memory map *)
Type ident = ``:string`` (* Identifier for variable name *)
Type word_one = ``:word1`` (* 1-bit word *)
Type word_eight = ``:word8`` (* 8-bit word *)
Type word_sixteen = ``:word16`` (* 16-bit word *)
Type word_thirtytwo = ``:word32`` (* 32-bit word *)
Type word_sixtyfour = ``:word64`` (* 64-bit word *)
Type word_hundredtwentyeight = ``:word128`` (* 128-bit word *)
val _ = Hol_datatype ` 
bir_immtype_t =  (* immediate typing size *)
   Bit1
 | Bit8
 | Bit16
 | Bit32
 | Bit64
 | Bit128
`;
val _ = Hol_datatype ` 
bir_imm_t =  (* immediates *)
   Imm1 of word_one
 | Imm8 of word_eight
 | Imm16 of word_sixteen
 | Imm32 of word_thirtytwo
 | Imm64 of word_sixtyfour
 | Imm128 of word_hundredtwentyeight
`;
val _ = Hol_datatype ` 
bir_endian_t =  (* endian for memory operations *)
   BEnd_BigEndian
 | BEnd_LittleEndian
 | BEnd_NoEndian
`;
val _ = Hol_datatype ` 
bir_var_t =  (* variable to lookup in environment *)
   BVar of ident
`;
val _ = Hol_datatype ` 
bir_binexp_t =  (* binary expressions *)
   BIExp_And
 | BIExp_Plus
`;
val _ = Hol_datatype ` 
bir_unaryexp_t =  (* unary expressions *)
   BIExp_ChangeSign
 | BIExp_Not
`;
val _ = Hol_datatype ` 
bir_binpred_t =  (* binary predicates *)
   BIExp_Equal
 | BIExp_LessThan
`;
val _ = Hol_datatype ` 
bir_type_t =  (* general typing *)
   BType_Imm of bir_immtype_t
 | BType_Mem of bir_immtype_t => bir_immtype_t
`;
val _ = Hol_datatype ` 
bir_exp_t =  (* BIR expressions *)
   BExp_Const of bir_imm_t
 | BExp_MemConst of bir_immtype_t => bir_immtype_t => mmap (* address type / value type *)
 | BExp_Den of bir_var_t
 | BExp_BinExp of bir_binexp_t => bir_exp_t => bir_exp_t
 | BExp_UnaryExp of bir_unaryexp_t => bir_exp_t
 | BExp_BinPred of bir_binpred_t => bir_exp_t => bir_exp_t
 | BExp_IfThenElse of bir_exp_t => bir_exp_t => bir_exp_t
 | BExp_Load of bir_exp_t => bir_exp_t => bir_endian_t => bir_immtype_t (* Memory value / Address Value (Imm) / Endian / Type of where to load *)
 | BExp_Store of bir_exp_t => bir_exp_t => bir_endian_t => bir_exp_t (* Memory value / Address Value (Imm) / Endian / Value to store *)
`;
val _ = Hol_datatype ` 
bir_val_t =  (* values for evaluation relation *)
   BVal_Imm of bir_imm_t
 | BVal_Mem of bir_immtype_t => bir_immtype_t => mmap (* address type / value type *)
`;
(* Booleans *)

Definition bool2w_def:
  bool2w b = (if b then 1w else 0w):word1
End

Definition bool2b_def:
  bool2b b = Imm1 (bool2w b)
End

Definition birT_def:
  birT = BVal_Imm (Imm1 1w)
End

Definition birF_def:
  birF = BVal_Imm (Imm1 0w)
End

(* Correction Theorems of boolean functions *)
Theorem bool2b_T_eq_birT:
  BVal_Imm (bool2b T) = birT
Proof
  rw [bool2b_def, bool2w_def, birT_def]
QED

Theorem bool2b_F_eq_birF:
  BVal_Imm (bool2b F) = birF
Proof
  rw [bool2b_def, bool2w_def, birF_def]
QED

(* Utility functions *)
Definition bir_dest_bool_val_def:
  (bir_dest_bool_val (BVal_Imm (Imm1 w)) = SOME (w = 1w)) /\
  (bir_dest_bool_val _ = NONE)
End

Definition val_from_imm_option_def:
  (val_from_imm_option NONE = NONE) /\
  (val_from_imm_option (SOME imm) = SOME (BVal_Imm imm))
End

(* ------ Env ------- *)

Datatype:
  bir_var_environment_t = BEnv (ident -> (bir_val_t option))
End

(* Lookup function *)
Definition bir_env_lookup_def:
  bir_env_lookup (BEnv env) (BVar id) = env id
End

(* Lookup relation *)
Definition bir_env_lookup_rel_def:
  bir_env_lookup_rel (BEnv env) (BVar id) a = (env id = (SOME a)) 
End

(* Empty environment *)
Definition bir_empty_env_def:
  bir_empty_env = BEnv (\x. NONE)
End

(* Update environment *)
(* Slightly differs from original as we donâ€™t check for existence here *)
Definition bir_env_update_def:
  bir_env_update ((BEnv env):bir_var_environment_t) (BVar id) v = BEnv ((id =+ SOME v) env)
End

Theorem bir_env_lookup_empty:
  !var v. ~(bir_env_lookup_rel bir_empty_env var v)
Proof
  Cases_on `var` >>
  rw [bir_empty_env_def, bir_env_lookup_rel_def]
QED

Theorem bir_env_lookup_rel_update:
  !env var v. bir_env_lookup_rel (bir_env_update env var v) var v 
Proof
  Cases_on `var` >> Cases_on `env` >>
  rw [bir_env_update_def, bir_env_lookup_rel_def]
QED

Theorem bir_env_lookup_update:
  !env var v. bir_env_lookup (bir_env_update env var v) var = SOME v 
Proof
  rpt gen_tac >>
  Cases_on `var` >> Cases_on `env` >>
  rw [bir_env_update_def, bir_env_lookup_def]
QED

Theorem bir_env_lookup_update_neq:
  !env var1 var2 v. 
    var1 <> var2 ==>
      bir_env_lookup (bir_env_update env var1 v) var2 = bir_env_lookup env var2
Proof
  Cases_on `var1` >> Cases_on `var2` >>
  rw [fetch "-" "bir_var_t_11"] >>
  Cases_on `env` >>
  simp [bir_env_update_def] >>
  rw [bir_env_lookup_def] >>
  EVAL_TAC >>
  metis_tac []
QED

(* Lookup and relation are the same *)
Theorem bir_env_lookup_eq_rel:
  !env var v. bir_env_lookup_rel env var v <=> bir_env_lookup env var = SOME v
Proof
  rpt strip_tac >>
  Cases_on `env` >>
  Cases_on `var` >>
    rw [bir_env_lookup_def, bir_env_lookup_rel_def]
QED


(* Injective *)
Theorem bir_env_lookup_rel_inj:
  !env var v1 v2.
    bir_env_lookup_rel env var v1 ==>
    bir_env_lookup_rel env var v2 ==>
    v1 = v2
Proof
  Cases_on `env` >> Cases_on `var` >>
    simp [bir_env_lookup_rel_def]
QED

(* --------- Typing ------- *)

(* Gives the size of an immediate as a number *)
Definition size_of_bir_immtype_def:
  (size_of_bir_immtype Bit1 = 1) /\
  (size_of_bir_immtype Bit8 = 8) /\
  (size_of_bir_immtype Bit16 = 16) /\
  (size_of_bir_immtype Bit32 = 32) /\
  (size_of_bir_immtype Bit64 = 64) /\
  (size_of_bir_immtype Bit128 = 128) 
End

(* Typing function for immediates *)
Definition type_of_bir_imm_def:
  (type_of_bir_imm (Imm1 w) = Bit1) /\
  (type_of_bir_imm (Imm8 w) = Bit8) /\
  (type_of_bir_imm (Imm16 w) = Bit16) /\
  (type_of_bir_imm (Imm32 w) = Bit32) /\
  (type_of_bir_imm (Imm64 w) = Bit64) /\
  (type_of_bir_imm (Imm128 w) = Bit128)
End

(* Typing function for values *)
Definition type_of_bir_val_def:
  (type_of_bir_val (BVal_Imm imm) = (BType_Imm (type_of_bir_imm imm))) /\
  (type_of_bir_val (BVal_Mem aty vty mmap) = (BType_Mem aty vty) )
End

Type bir_var_environment_t = ``:bir_var_environment_t``

Type n = ``:num``
(** definitions *)

(* defns type_of_bir_exp *)
Inductive type_of_bir_exp:
(* defn type_of_bir_exp *)

[BExp_Const:] (! (env:bir_var_environment_t) (bir_imm:bir_imm_t) .
(clause_name "BExp_Const")
 ==> 
( ( type_of_bir_exp env (BExp_Const bir_imm) (BType_Imm  (type_of_bir_imm  bir_imm ) ) )))

[BExp_MemConst:] (! (env:bir_var_environment_t) (bir_immtype1:bir_immtype_t) (bir_immtype2:bir_immtype_t) (mmap:mmap) .
(clause_name "BExp_MemConst")
 ==> 
( ( type_of_bir_exp env (BExp_MemConst bir_immtype1 bir_immtype2 mmap) (BType_Mem bir_immtype1 bir_immtype2) )))

[BExp_Den:] (! (env:bir_var_environment_t) (bir_var:bir_var_t) (bir_val:bir_val_t) .
(clause_name "BExp_Den") /\
(( (bir_env_lookup_rel  env   bir_var   bir_val ) ))
 ==> 
( ( type_of_bir_exp env (BExp_Den bir_var)  (type_of_bir_val  bir_val )  )))

[BExp_BinExp:] (! (env:bir_var_environment_t) (bir_binexp:bir_binexp_t) (bir_exp1:bir_exp_t) (bir_exp2:bir_exp_t) (bir_immtype:bir_immtype_t) .
(clause_name "BExp_BinExp") /\
(( ( type_of_bir_exp env bir_exp1 (BType_Imm bir_immtype) )) /\
( ( type_of_bir_exp env bir_exp2 (BType_Imm bir_immtype) )))
 ==> 
( ( type_of_bir_exp env (BExp_BinExp bir_binexp bir_exp1 bir_exp2) (BType_Imm bir_immtype) )))

[BExp_UnaryExp:] (! (env:bir_var_environment_t) (bir_unaryexp:bir_unaryexp_t) (bir_exp:bir_exp_t) (bir_immtype:bir_immtype_t) .
(clause_name "BExp_UnaryExp") /\
(( ( type_of_bir_exp env bir_exp (BType_Imm bir_immtype) )))
 ==> 
( ( type_of_bir_exp env (BExp_UnaryExp bir_unaryexp bir_exp) (BType_Imm bir_immtype) )))

[BExp_BinPred:] (! (env:bir_var_environment_t) (bir_binpred:bir_binpred_t) (bir_exp1:bir_exp_t) (bir_exp2:bir_exp_t) (bir_immtype:bir_immtype_t) .
(clause_name "BExp_BinPred") /\
(( ( type_of_bir_exp env bir_exp1 (BType_Imm bir_immtype) )) /\
( ( type_of_bir_exp env bir_exp2 (BType_Imm bir_immtype) )))
 ==> 
( ( type_of_bir_exp env (BExp_BinPred bir_binpred bir_exp1 bir_exp2) (BType_Imm Bit1) )))

[BExp_IfThenElse:] (! (env:bir_var_environment_t) (bir_exp:bir_exp_t) (bir_exp1:bir_exp_t) (bir_exp2:bir_exp_t) (bir_type:bir_type_t) .
(clause_name "BExp_IfThenElse") /\
(( ( type_of_bir_exp env bir_exp1 bir_type )) /\
( ( type_of_bir_exp env bir_exp2 bir_type )) /\
( ( type_of_bir_exp env bir_exp (BType_Imm Bit1) )))
 ==> 
( ( type_of_bir_exp env (BExp_IfThenElse bir_exp bir_exp1 bir_exp2) bir_type )))

[BExp_Load_NoEndian:] (! (env:bir_var_environment_t) (bir_exp1:bir_exp_t) (bir_exp2:bir_exp_t) (bir_immtype:bir_immtype_t) (bir_immtype1:bir_immtype_t) (bir_immtype2:bir_immtype_t) .
(clause_name "BExp_Load_NoEndian") /\
(( ( type_of_bir_exp env bir_exp1 (BType_Mem bir_immtype1 bir_immtype2) )) /\
( ( type_of_bir_exp env bir_exp2 (BType_Imm bir_immtype1) )) /\
( (  (  (size_of_bir_immtype  bir_immtype )   MOD   (size_of_bir_immtype  bir_immtype2 )  )   =   0  ) ) /\
( (  (  (size_of_bir_immtype  bir_immtype )   DIV   (size_of_bir_immtype  bir_immtype2 )  )   <=   (2**  (size_of_bir_immtype  bir_immtype1 )  )  ) ) /\
( (  (  (size_of_bir_immtype  bir_immtype )   DIV   (size_of_bir_immtype  bir_immtype2 )  )   =   1  ) ))
 ==> 
( ( type_of_bir_exp env (BExp_Load bir_exp1 bir_exp2 BEnd_NoEndian bir_immtype) (BType_Imm bir_immtype) )))

[BExp_Load_BigEndian:] (! (env:bir_var_environment_t) (bir_exp1:bir_exp_t) (bir_exp2:bir_exp_t) (bir_immtype:bir_immtype_t) (bir_immtype1:bir_immtype_t) (bir_immtype2:bir_immtype_t) .
(clause_name "BExp_Load_BigEndian") /\
(( ( type_of_bir_exp env bir_exp1 (BType_Mem bir_immtype1 bir_immtype2) )) /\
( ( type_of_bir_exp env bir_exp2 (BType_Imm bir_immtype1) )) /\
( (  (  (size_of_bir_immtype  bir_immtype )   MOD   (size_of_bir_immtype  bir_immtype2 )  )   =   0  ) ) /\
( (  (  (size_of_bir_immtype  bir_immtype )   DIV   (size_of_bir_immtype  bir_immtype2 )  )   <=   (2**  (size_of_bir_immtype  bir_immtype1 )  )  ) ))
 ==> 
( ( type_of_bir_exp env (BExp_Load bir_exp1 bir_exp2 BEnd_BigEndian bir_immtype) (BType_Imm bir_immtype) )))

[BExp_Load_LittleEndian:] (! (env:bir_var_environment_t) (bir_exp1:bir_exp_t) (bir_exp2:bir_exp_t) (bir_immtype:bir_immtype_t) (bir_immtype1:bir_immtype_t) (bir_immtype2:bir_immtype_t) .
(clause_name "BExp_Load_LittleEndian") /\
(( ( type_of_bir_exp env bir_exp1 (BType_Mem bir_immtype1 bir_immtype2) )) /\
( ( type_of_bir_exp env bir_exp2 (BType_Imm bir_immtype1) )) /\
( (  (  (size_of_bir_immtype  bir_immtype )   MOD   (size_of_bir_immtype  bir_immtype2 )  )   =   0  ) ) /\
( (  (  (size_of_bir_immtype  bir_immtype )   DIV   (size_of_bir_immtype  bir_immtype2 )  )   <=   (2**  (size_of_bir_immtype  bir_immtype1 )  )  ) ))
 ==> 
( ( type_of_bir_exp env (BExp_Load bir_exp1 bir_exp2 BEnd_LittleEndian bir_immtype) (BType_Imm bir_immtype) )))

[BExp_Store_NoEndian:] (! (env:bir_var_environment_t) (bir_exp1:bir_exp_t) (bir_exp2:bir_exp_t) (bir_exp3:bir_exp_t) (bir_immtype1:bir_immtype_t) (bir_immtype2:bir_immtype_t) (bir_immtype:bir_immtype_t) .
(clause_name "BExp_Store_NoEndian") /\
(( ( type_of_bir_exp env bir_exp1 (BType_Mem bir_immtype1 bir_immtype2) )) /\
( ( type_of_bir_exp env bir_exp2 (BType_Imm bir_immtype1) )) /\
( ( type_of_bir_exp env bir_exp3 (BType_Imm bir_immtype) )) /\
( (  (  (size_of_bir_immtype  bir_immtype )   MOD   (size_of_bir_immtype  bir_immtype2 )  )   =   0  ) ) /\
( (  (  (size_of_bir_immtype  bir_immtype )   DIV   (size_of_bir_immtype  bir_immtype2 )  )   <=   (2**  (size_of_bir_immtype  bir_immtype1 )  )  ) ) /\
( (  (  (size_of_bir_immtype  bir_immtype )   DIV   (size_of_bir_immtype  bir_immtype2 )  )   =   1  ) ))
 ==> 
( ( type_of_bir_exp env (BExp_Store bir_exp1 bir_exp2 BEnd_NoEndian bir_exp3) (BType_Mem bir_immtype1 bir_immtype2) )))

[BExp_Store_BigEndian:] (! (env:bir_var_environment_t) (bir_exp1:bir_exp_t) (bir_exp2:bir_exp_t) (bir_exp3:bir_exp_t) (bir_immtype1:bir_immtype_t) (bir_immtype2:bir_immtype_t) (bir_immtype:bir_immtype_t) .
(clause_name "BExp_Store_BigEndian") /\
(( ( type_of_bir_exp env bir_exp1 (BType_Mem bir_immtype1 bir_immtype2) )) /\
( ( type_of_bir_exp env bir_exp2 (BType_Imm bir_immtype1) )) /\
( ( type_of_bir_exp env bir_exp3 (BType_Imm bir_immtype) )) /\
( (  (  (size_of_bir_immtype  bir_immtype )   MOD   (size_of_bir_immtype  bir_immtype2 )  )   =   0  ) ) /\
( (  (  (size_of_bir_immtype  bir_immtype )   DIV   (size_of_bir_immtype  bir_immtype2 )  )   <=   (2**  (size_of_bir_immtype  bir_immtype1 )  )  ) ))
 ==> 
( ( type_of_bir_exp env (BExp_Store bir_exp1 bir_exp2 BEnd_BigEndian bir_exp3) (BType_Mem bir_immtype1 bir_immtype2) )))

[BExp_Store_LittleEndian:] (! (env:bir_var_environment_t) (bir_exp1:bir_exp_t) (bir_exp2:bir_exp_t) (bir_exp3:bir_exp_t) (bir_immtype1:bir_immtype_t) (bir_immtype2:bir_immtype_t) (bir_immtype:bir_immtype_t) .
(clause_name "BExp_Store_LittleEndian") /\
(( ( type_of_bir_exp env bir_exp1 (BType_Mem bir_immtype1 bir_immtype2) )) /\
( ( type_of_bir_exp env bir_exp2 (BType_Imm bir_immtype1) )) /\
( ( type_of_bir_exp env bir_exp3 (BType_Imm bir_immtype) )) /\
( (  (  (size_of_bir_immtype  bir_immtype )   MOD   (size_of_bir_immtype  bir_immtype2 )  )   =   0  ) ) /\
( (  (  (size_of_bir_immtype  bir_immtype )   DIV   (size_of_bir_immtype  bir_immtype2 )  )   <=   (2**  (size_of_bir_immtype  bir_immtype1 )  )  ) ))
 ==> 
( ( type_of_bir_exp env (BExp_Store bir_exp1 bir_exp2 BEnd_LittleEndian bir_exp3) (BType_Mem bir_immtype1 bir_immtype2) )))
End

Definition is_exp_well_typed_def:
  is_exp_well_typed env exp = ?ty. type_of_bir_exp env exp ty
End

(* 1 bit values are booleans *)
Theorem bit1_is_boolean:
  !v. type_of_bir_val v = (BType_Imm Bit1) ==> (v = birT \/ v = birF)
Proof
  Cases_on `v` >>
    Cases_on `b` >>
      rw [birT_def, birF_def, type_of_bir_val_def, type_of_bir_imm_def] >>
      Cases_on `c` >>
        fs [dimword_1]
QED


val _ = export_theory ();



